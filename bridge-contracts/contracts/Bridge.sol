// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/**
 * @title Bridge
 * @dev This contract facilitates bridging assets between Xorion and Ethereum.
 * It acts as the Ethereum-side counterpart to the Xorion bridge pallet.
 * It allows for locking wrapped assets to be released on Xorion and
 * releasing (minting) wrapped assets on Ethereum based on a federated multi-signature
 * from a set of trusted relayers.
 */
contract Bridge is ERC20, Ownable {
    using ECDSA for bytes32;

    // --- State Variables ---

    // A list of trusted relayer addresses.
    mapping(address => bool) public isRelayer;
    // The number of signatures required to approve a release.
    uint256 public relayerThreshold;
    // Mapping to prevent replay attacks for messages from Xorion.
    mapping(bytes32 => bool) public processedMessages;
    // Emergency pause flag.
    bool public paused;

    // --- Events ---

    /// @notice Emitted when a user locks wrapped tokens on Ethereum to be released on Xorion.
    /// @param from The Ethereum account locking the tokens.
    /// @param to The recipient's Xorion account address (as bytes).
    /// @param amount The amount of tokens locked.
    /// @param messageId The canonical hash of the event data.
    event Locked(address indexed from, bytes to, uint256 amount, bytes32 indexed messageId);

    /// @notice Emitted when wrapped tokens are released (minted) on Ethereum.
    /// @param to The recipient of the minted tokens.
    /// @param amount The amount of tokens released.
    /// @param messageId The message ID from the Xorion side.
    event Released(address indexed to, uint256 amount, bytes32 indexed messageId);

    /// @notice Emitted when the list of relayers is updated.
    event RelayersUpdated(address[] relayers, bool[] status);

    /// @notice Emitted when the relayer signature threshold is updated.
    event RelayerThresholdUpdated(uint256 newThreshold);

    /// @notice Emitted when the contract is paused or unpaused.
    event PausedSet(bool isPaused);

    // --- Constructor ---

    constructor(
        string memory name,
        string memory symbol,
        address[] memory initialRelayers,
        uint256 _relayerThreshold
    ) ERC20(name, symbol) Ownable(msg.sender) {
        require(
            _relayerThreshold > 0 && _relayerThreshold <= initialRelayers.length,
            "Invalid number of required signatures"
        );
        relayerThreshold = _relayerThreshold;
        for (uint256 i = 0; i < initialRelayers.length; i++) {
            isRelayer[initialRelayers[i]] = true;
        }
    }

    // --- Modifiers ---

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    // --- Bridge Functions ---

    /**
     * @notice Releases (mints) wrapped tokens on Ethereum after a lock on Xorion.
     * @dev This is the counterpart to the Xorion pallet's `lock` function.
     * It requires a multi-signature proof from the federation of relayers.
     * @param messageId The exact 32-byte hash generated by the Substrate pallet.
     * @param to The recipient's Ethereum address.
     * @param amount The amount to mint.
     * @param signatures An array of 65-byte signatures (r,s,v) from relayers.
     */
    function release(
        bytes32 messageId,
        address to,
        uint256 amount,
        bytes[] memory signatures
    ) public whenNotPaused {
        require(signatures.length >= relayerThreshold, "Threshold not met");

        require(!processedMessages[messageId], "Message already processed");

        // Verify the signatures
        verifySignatures(messageId, signatures);

        processedMessages[messageId] = true;
        _mint(to, amount);

        emit Released(to, amount, messageId);
    }

    /**
     * @notice Locks (burns) wrapped tokens on Ethereum to be released on Xorion.
     * @dev This is the counterpart to the Xorion pallet's `release` function.
     * @param amount The amount of tokens to lock.
     * @param xorionRecipient The recipient's Xorion account address (as bytes).
     */
    function lock(uint256 amount, bytes memory xorionRecipient) public whenNotPaused {
        require(amount > 0, "Amount must be positive");

        // Construct the canonical message hash for the Ethereum -> Xorion direction.
        // This should be defined by the bridge protocol. Here we use direction = 1.
        // The nonce could be a contract-level nonce or based on block number.
        uint256 nonce = block.number;
        bytes32 messageId = keccak256(
            abi.encodePacked(uint64(1), uint8(1), uint128(amount), msg.sender, xorionRecipient, nonce)
        );

        _burn(msg.sender, amount);
        emit Locked(msg.sender, xorionRecipient, amount, messageId);
    }

    // --- Internal and Private Functions ---

    /**
     * @dev Verifies that a sufficient number of valid, unique relayers have signed the message.
     */
    function verifySignatures(bytes32 messageId, bytes[] memory signatures) private view {
        address[] memory seenRelayers = new address[](signatures.length);
        uint256 validSignatures = 0;

        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(messageId);

        for (uint i = 0; i < signatures.length; i++) {
            require(signatures[i].length == 65, "Invalid signature length");
            address signer = ECDSA.recover(ethSignedMessageHash, signatures[i]);
            require(isRelayer[signer], "Invalid signer");

            bool seen = false;
            for (uint j = 0; j < validSignatures; j++) {
                if (seenRelayers[j] == signer) {
                    seen = true;
                    break;
                }
            }
            if (!seen) {
                seenRelayers[validSignatures] = signer;
                validSignatures++;
            }
        }
        require(validSignatures >= relayerThreshold, "Threshold not met");
    }

    // --- Admin Functions ---

    function setPaused(bool _paused) public onlyOwner {
        paused = _paused;
        emit PausedSet(_paused);
    }

    function setRelayerThreshold(uint256 _newThreshold) public onlyOwner {
        require(_newThreshold > 0, "Threshold must be positive");
        relayerThreshold = _newThreshold;
        emit RelayerThresholdUpdated(_newThreshold);
    }

    function updateRelayers(address[] memory _relayers, bool[] memory _status) public onlyOwner {
        require(_relayers.length == _status.length, "Input array length mismatch");
        for (uint i = 0; i < _relayers.length; i++) {
            isRelayer[_relayers[i]] = _status[i];
        }
        emit RelayersUpdated(_relayers, _status);
    }
}
